import { Injectable } from '@angular/core';
import { MixAndMatch, MixAndMatchArray, Question, Questions } from 'src/app/model/questions.model';
import { AngularFirestoreModule, DocumentSnapshot, AngularFirestore } from '@angular/fire/firestore';
import { QuestionTypes } from 'src/app/model/question-types-enum';

@Injectable({
  providedIn: 'root'
})
export class QuestionsService {
  currentQuestions: Question[];
  currentQuestion: Question;
  answeredQuestions: Question[] = [];
  answeredMixAndMatch: Questions[] = [];
  currentIndex: number;
  wrongAnswers: number;
  rightAnswers: number;
  points: number;
  multipleTF = false; 
  fillInTheBlankTF = false; 
  mixAndMatchTF = true; 
  dropDownTF = false; 
  currentMixAndMatch: Questions; 
  mixAndMatch: Questions[];
  questionTypes = QuestionTypes;
  mixAndMatchCC: Questions[];
  currentMixAndMatchAnswers: string[] = [];
  dropDownTestsTF = true;

  constructor(private firestore: AngularFirestore) {
    this.GetQuestions('CyberSec');
    // this.GetMixAndMatch('Journalism');
  }

  GetQuestions(type: string) {
    // console.log(type);
    const ret = this.firestore.collection('FBLA').doc(type + 'Questions').get();
    // const ret is told to look into firebase and look for the FBLA project 
    // const ret also uses the type selected in questions.html and adds Question to the string in order 
    // to look for the questions corresponding to that quiz/test
    ret.subscribe(res => {
      console.log(res);
      // res.subscribe makes res true
      if (res.exists) {
        const questions = (res.data());
        this.currentQuestions = questions.questions;
        console.log(this.currentQuestions);
        // currentQuestions array is set equal to the array of questions in the database
        if (this.currentQuestions) {
          this.wrongAnswers = 0;
          this.rightAnswers = 0;
          this.points = 0;
          // sets all the score variables equal to zero in order begin the counting process of the test/quiz
          this.currentQuestion = new Question();
          this.currentQuestion = this.SetCurrentQuestion();
          // sets currentQuestion equal to SetCurrentQuestion and runs it
          this.setQuestionType(); 
        } else {
          this.currentQuestions = [];
          console.log(this.currentQuestions);
        }
      } 
    }
      , err => {
        console.log('Something went wrong while getting ' + type + 'questions', err);
      });
  }

  GetMixAndMatch(type: string) { 
    this.mixAndMatchTF = true;
    const ret = this.firestore.collection('FBLA').doc(type + 'MixAndMatch').get();
    // Looks into FBLA in firebase and adds the type selected to 'MixAndMatch' to get the corresponding MixAndMatch
    ret.subscribe(res => {
      if (res.exists) {
        const results = (res.data());
        console.log(results);
        this.mixAndMatch = results.MAndMQuestions;
        this.mixAndMatchCC = results.MAndMQuestions;
        this.currentMixAndMatch = this.SetCurrentMixAndMatch();
        this.setCurrentMixAndMatchAnswers();
      } 
    }
      , err => {
        console.log('Something went wrong while getting ' + type + 'Mix and Match', err);
      });
  }

  SetCurrentMixAndMatch() : Questions { 
    console.log(this.mixAndMatch);
    const randomIndex = Math.floor(Math.random() * (this.mixAndMatch.length - .5));
    this.currentIndex = randomIndex;
    return this.mixAndMatch[this.currentIndex];
  }

  setCurrentMixAndMatchAnswers() { 
    this.currentMixAndMatch.questions.forEach(question => {
      console.log(question.correctAnswer); 
      this.currentMixAndMatchAnswers.push(question.correctAnswer);
    });
  }

  mixAndMatchQuestionWasAnswered(index: number) { 
    this.currentMixAndMatchAnswers.splice(index, 1);
    if (this.currentMixAndMatchAnswers.length == 0) {
      this.mixAndMatchTF = false;
    }
  }

  SetCurrentQuestion(): Question {
    const randomIndex = Math.floor(Math.random() * (this.currentQuestions.length - .5));
    // const randomIndex is a number generated by using math.random to multiply the length of the currentQuestions.length -.5
    // Math.floor is then used to round the number down to avoid the use of decimal numbers
    this.currentIndex = randomIndex;
    // randomInedex is set equal to currentIndex
    return this.currentQuestions[this.currentIndex];
    // the currentIndex number is then used as the currentQuestions array's index 
    // Doing this allows the randomization of the questions as opposed to just displaying the array of questions in order
  }

  setQuestionType() { 
    this.fillInTheBlankTF = false; 
    this.multipleTF = false; 
    this.dropDownTF = false; 
    // All booleans are set to false in order to reuse this method
    const typeNumber = Math.floor(Math.random()*3); 
    // Math.random is used to generate a number, this number will always be between 0 and 1 
    // This number is then multiplied by three in order to make this number between 0 and 3 
    // Because Math.random is used the number may contain a decimal and the number generated might look something like "1.3"
    // The question types have an assigned number from 0-2  
    // Math.floor is then used to round this number to a whole number to avoid the use of decimals
    // console.log((typeNumber == this.questionTypes.DropDown));
    // typeNumber is then compared to QuestionTypes in quesitno-types-enums.ts
    if (typeNumber == this.questionTypes.MultipleChoice) {
      this.multipleTF = true; 
    } else if (typeNumber == this.questionTypes.FillInTheBlank) {
      this.fillInTheBlankTF = true; 
    } 
    else if (typeNumber == this.questionTypes.DropDown) { 
      this.dropDownTF = true;
    }
    // If typeNumber is equal to one of the three question types, it will turn that boolean true 
    // console.log(this.dropDownTF);
    console.log(typeNumber);
  }

  GetResult(answer: string) {
    if (answer === this.currentQuestion.correctAnswer) {
      this.rightAnswers++;
      this.points++;
      this.currentQuestion.isCorrectTF = true;
      // The answer selected is compared to the correctAnswer in the database 
      // If the answer selected matches the correctAnswer then 1 one will be added to the
      // rightAnswers integer and the points integer
    } else {
      this.wrongAnswers++;
      this.currentQuestion.isCorrectTF = false;
      // If the answer selected does not match the wrongAnswers will have 1 added to it 
      // rightAnswers and wrongAnswers are counters used for the resutls
    }
    this.currentQuestion.isAnsweredTF = true;
    // Making isAnsweredTF will allow the Next button to be displayed 
  }

  getResultMixAndMatch(question: Question, answer: string, questionIndex: number) {
    if (answer === question.correctAnswer) {
      console.log('You are correct! You gained a point.'); // maybe questions have a difficulty rating or points given
      this.rightAnswers++;
      this.points++;
      this.mixAndMatch[this.currentIndex].questions[questionIndex].isCorrectTF = true;
    } else {
      this.wrongAnswers++;
      this.mixAndMatch[this.currentIndex].questions[questionIndex].isCorrectTF = false;
    }
    this.mixAndMatch[this.currentIndex].questions[questionIndex].isAnsweredTF = true;
  
  }

  NextQuestion() {
    this.currentQuestions.splice(this.currentIndex, 1);
    this.answeredQuestions.push(this.currentQuestion);
    // The pushing and slicing will shorten the array of the questions available and tracks to progress of the quiz/test
    this.currentQuestion = this.SetCurrentQuestion();
    // the NextQuestion method then runs the SetCurrentQUestion Method to display another question
    this.setQuestionType(); 
    // Lastly the setQuestionType method is run to set the format the question will be displayed as 
  }

  saveQuestion(question: Question, questionType: string) {
    const q = new Questions();
    this.currentQuestions.push({...question});
    q.questions = this.currentQuestions;
    console.log(this.currentQuestions);
    const questions = {...q};
    const ret = this.firestore.collection('FBLA').doc(questionType + 'Questions')
      .set(questions, { merge: true })
      .then(res => {
        console.log('Saved question: result', res);
      })
      .catch(err => {
        console.log('Could not save question', err);
      });
  }
 
}
